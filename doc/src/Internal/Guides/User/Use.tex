\chapter{How to use the CRTM library}
%====================================
\section{Step by Step Guide}
%===========================
This section will hopefully get you started using the CRTM library as quickly as possible. Refer to the following sections for more information about the structures and interfaces.

The examples shown here assume you are processing one sensor at a time. The CRTM can handle multiple sensors at once, but specifying the input information in a simple way is difficult; e.g. the \hyperref[sec:geometryinfo_structure]{\GeometryInfo} structure that is used to specify the sensor viewing geometry -- even sensors on the same platform typically have different numbers of fields-of-view (FOVs) per scan. For multiple sensor processing, we'll assume they will be separately processed in parallel.

Because there are many variations in what information is known ahead of time (and by ``ahead of time'' we mean at compile-time of your code), let's approach this via examples for a fixed number of atmospheric profiles, and a known sensors. It is left as an exercise to the reader to tailor calls to the CRTM in their application code according to their particular needs.

With regards to sensor identification, the CRTM uses a character string -- refered to as the \f{Sensor\_Id} -- to distinguish sensors and platforms. The lists of currently supported sensors, along with their associated \f{Sensor\_Id}'s, are shown in appendix \ref{sec:sensor_id}.


\newcounter{step}
\newcounter{example}[subsection]

\subsection{Step 1: Access the CRTM module}
%------------------------------------------
\stepcounter{step}
\label{sec:access_step}
All of the CRTM user procedures, parameters, and derived data type definitions are accessible via the container module \f{CRTM\_Module}. Thus, one needs to put the following statement in any calling program, module or procedure,

\qquad\f{USE CRTM\_Module}

Once you become familiar with the components of the CRTM you require, you can also specify an \f{ONLY} clause with the \f{USE} statement,

\qquad\f{USE CRTM\_Module}[\f{, ONLY:}\textit{only-list}]

where \textit{only-list} is a list of the symbols you want to ``import'' from \f{CRTM\_Module}. This latter form is the preferred style for self-documenting your code; e.g. when you give the code to someone else, they will be able to identify from which module various symbols in your code originate.


\subsection{Step 2: Declare the CRTM structures}
%-----------------------------------------------
\refstepcounter{step}
\label{sec:declare_step}
To compute satellite radiances you need to declare structures for the following information,\vspace{-2ex}
\begin{enumerate}
  \item Atmospheric profile data such as pressure, temperature, absorber amounts, clouds, aerosols, etc. Handled using the \hyperref[sec:atmosphere_structure]{\Atmosphere} structure.
  \item Surface data such as type of surface, temperature, surface type specific parameters etc. Handled using the \hyperref[sec:surface_structure]{\Surface} structure.
  \item Geometry information such as sensor scan angle, zenith angle, etc. Handled using the \hyperref[sec:geometryinfo_structure]{\GeometryInfo} structure.
  \item Instrument information, particularly which instrument(s), or sensor(s)\footnote{The terms ``instrument'' and ``sensor'' are used interchangeably in this document.}, you want to simulate. Handled using the \hyperref[sec:channelinfo_structure]{\ChannelInfo} structure.
  \item Results of the radiative transfer calculation. Handled using the \hyperref[sec:rtsolution_structure]{\RTSolution} structure.
  \item Optional inputs. Handled using the \hyperref[sec:options_structure]{\Options} structure.
\end{enumerate}

Let's assume you want to process, say, 50 profiles for the NOAA-18 AMSU-A sensor which has 15 channels. The forward model declarations would look something like,
\begin{alltt}
  ! Processing parameters
  INTEGER     , PARAMETER :: N_SENSORS  =  1
  INTEGER     , PARAMETER :: N_CHANNELS = 15
  INTEGER     , PARAMETER :: N_PROFILES = 50
  CHARACTER(*), PARAMETER :: SID(N_SENSORS) = (/'amsua_n18'/)
  TYPE(\hyperref[fig:CRTM_ChannelInfo_type_structure]{CRTM_ChannelInfo_type})  :: chInfo(N_SENSORS)  
  TYPE(\hyperref[fig:CRTM_GeometryInfo_type_structure]{CRTM_GeometryInfo_type}) :: gInfo(N_PROFILES)  
  ! Forward declarations
  TYPE(\hyperref[fig:CRTM_Atmosphere_type_structure]{CRTM_Atmosphere_type})   :: atm(N_PROFILES)
  TYPE(\hyperref[fig:CRTM_Surface_type_structure]{CRTM_Surface_type})      :: sfc(N_PROFILES)
  TYPE(\hyperref[fig:CRTM_RTSolution_type_structure]{CRTM_RTSolution_type})   :: rts(N_CHANNELS,N_PROFILES)\end{alltt}
If you are also interested in calling the K-matrix model, you will also need the following declarations,
\begin{alltt}
  ! K-Matrix declarations
  TYPE(\hyperref[fig:CRTM_Atmosphere_type_structure]{CRTM_Atmosphere_type})   :: atm_K(N_CHANNELS,N_PROFILES)
  TYPE(\hyperref[fig:CRTM_Surface_type_structure]{CRTM_Surface_type})      :: sfc_K(N_CHANNELS,N_PROFILES)
  TYPE(\hyperref[fig:CRTM_RTSolution_type_structure]{CRTM_RTSolution_type})   :: rts_K(N_CHANNELS,N_PROFILES)\end{alltt}


\subsection{Step 3: Initialise the CRTM}
%---------------------------------------
\stepcounter{step}
\label{sec:init_step}
The CRTM is initialised by calling the \hyperref[sec:CRTM_Init_interface]{\f{CRTM\_Init()}} function. This loads all the various coefficient data used by CRTM components into memory for later use. We'll assume that all the required datafiles reside in the subdirectory \f{./coeff\_data} and follow on from the example of Step \ref{sec:declare_step}. The CRTM initialisation is profile independent, so we're only dealing with sensor information here. The CRTM initialisation function call looks like,
\begin{alltt}
  INTEGER :: errStatus
  ....
  errStatus = \hyperref[sec:CRTM_Init_interface]{CRTM_Init}( chInfo, Sensor_Id=SID, File_Path='./coeff_data' )
  IF ( errStatus /= SUCCESS ) THEN 
    \textrm{\textit{handle error...}}
  END IF\end{alltt}

Here we see for the first time how the CRTM functions let you know if they were successful. As you can see the \hyperref[sec:CRTM_Init_interface]{\f{CRTM\_Init()}} function result is an error status that is checked against a parameterised integer error code, \f{SUCCESS}. The function result should \emph{not} be tested against the actual value of the error code, just its parameterised name. Other available error code parameters are \f{FAILURE}, \f{WARNING}, and \f{INFORMATION} -- although the latter is never used as a function result.


\subsection{Step 4: Allocate the CRTM structures}
%------------------------------------------------
\stepcounter{step}
Now we need to allocate the \emph{internal} components of the various CRTM structures where necessary to hold the input or output data. In this case, functions are used to perform these ``internal'' allocations. The function naming convention is \f{CRTM\_Allocate\_}\textit{name} where, for typical usage, the CRTM structures that need to be allocated are the \hyperref[sec:atmosphere_structure]{\Atmosphere}, \hyperref[sec:rtsolution_structure]{\RTSolution} and, if used, \hyperref[sec:options_structure]{\Options} structures. Potentially, the \hyperref[sec:sensordata_structure]{\SensorData} component of the \hyperref[sec:surface_structure]{\Surface} structure may also need to be allocated to allow for input of sensor observations for some of the NESDIS microwave surface emissivity models.

\subsubsection{Allocation of the Atmosphere structures}
%......................................................
First, we'll allocate the atmosphere structures to the required dimensions. The forward variable is allocated like so:
\begin{alltt}
  ! Allocate the forward atmosphere structure
  errStatus = \hyperref[sec:CRTM_Allocate_Atmosphere_interface]{CRTM_Allocate_Atmosphere}( n_Layers   , &  ! Input
                                        N_ABSORBERS, &  ! Input (always 2)
                                        n_Clouds   , &  ! Input
                                        n_Aerosols , &  ! Input
                                        atm          )  ! Output
  IF ( errStatus /= SUCCESS ) THEN 
    \textrm{\textit{handle error...}}
  END IF\end{alltt}
and the K-matrix variable is allocated by looping over all profiles,
\begin{alltt}
  ! Allocate the K-matrix atmosphere structure
  DO m = 1, N_PROFILES
    errStatus = \hyperref[sec:CRTM_Allocate_Atmosphere_interface]{CRTM_Allocate_Atmosphere}( n_Layers   , &  ! Input
                                          N_ABSORBERS, &  ! Input (always 2)
                                          n_Clouds   , &  ! Input
                                          n_Aerosols , &  ! Input
                                          atm_k(:,m)   )  ! Output
    IF ( errStatus /= SUCCESS ) THEN 
      \textrm{\textit{handle error...}}
    END IF
  END DO\end{alltt}
Note that the number of absorbers is in all capitals. In the CRTM, this style convention indicates a parameter. A parameter is used for the number of absorbers in the current CRTM release because the number of absorbers is fixed at two: water vapour and ozone. Future CRTM releases will allow more flexibility in selecting the number of absorbers, but currently the number must be set to two.


\subsection{Step 5: Fill the CRTM input structures with data}
%------------------------------------------------------------
\stepcounter{step}
This step simply entails filling the input \texttt{atm}, \texttt{sfc} and \texttt{gInfo} structures with the required information. However, there are some issues that need to be mentioned:
\begin{itemize}
  \item In the CRTM, all profile layering is from top-of-atmosphere (TOA) to surface (SFC). So, for an atmospheric profile layered as $k = 1,2,...,K$, layer 1 is the TOA layer and layer $K$ is the SFC layer.
  \item In the \hyperref[sec:atmosphere_structure]{\Atmosphere} structure, the \texttt{Climatology} component is not yet used.
  \item In the \hyperref[sec:atmosphere_structure]{\Atmosphere} structure, \emph{both} the level and layer pressure profiles must be specified.
  \item In the \hyperref[sec:atmosphere_structure]{\Atmosphere} structure, the absorber profile data units \emph{must} be mass mixing ratio for water vapour and ppmv for ozone. The \texttt{Absorber\_Units} component is not yet utilised to allow conversion of different user-supplied concentration units.
  \item In the \hyperref[sec:surface_structure]{\Surface} structure, the sum of the coverage types \emph{must} add up to 1.0.
  \item In the \hyperref[sec:geometryinfo_structure]{\GeometryInfo} structure, the sensor zenith and sensor scan angles should be consistent.
  \item Graphical definitions of the \hyperref[sec:geometryinfo_structure]{\GeometryInfo} structure sensor scan, sensor zenith, sensor azimuth, source zenith, and source azimuth angles are shown in figures \ref{fig:gInfo_sensor_scan_angle}, \ref{fig:gInfo_sensor_zenith_angle}, \ref{fig:gInfo_sensor_azimuth_angle}, \ref{fig:gInfo_source_zenith_angle}, and  \ref{fig:gInfo_source_azimuth_angle} respectively.
\end{itemize}
For the K-matrix structures, you should zero the K-matrix \emph{outputs}, \texttt{atm\_K}, \texttt{sfc\_K},
\begin{alltt}
  ! Zero the K-matrix OUTPUT structures
  CALL \hyperref[sec:CRTM_Zero_Atmosphere_interface]{CRTM_Zero_Atmosphere}( atm_K )
  CALL \hyperref[sec:CRTM_Zero_Surface_interface]{CRTM_Zero_Surface}( sfc_K )\end{alltt}
and initialise the K-matrix \emph{input}, \texttt{rts\_K}, to provide you with the derivatives you want. For example, if you want the \texttt{atm\_K}, \texttt{sfc\_K} outputs to contain brightness temperature derivatives, you should initialise \texttt{rts\_K} like so,
\begin{alltt}
  ! Initialise the K-Matrix INPUT to provide dTb/dx derivatives
  rts_K%Radiance = ZERO
  rts_K%Brightness_Temperature = ONE\end{alltt}
Alternatively, if you want radiance derivatives returned in \texttt{atm\_K} and \texttt{sfc\_K}, the \texttt{rts\_K} structure should be initialised like so,  
\begin{alltt}
  ! Initialise the K-Matrix INPUT to provide dR/dx derivatives
  rts_K%Radiance = ONE
  rts_K%Brightness_Temperature = ZERO\end{alltt}

For computational efficiency, there is minimal input data checking done so the GIGO\footnote{Garbage In, Garbage Out} principle applies.


\subsection{Step 6: Call the required CRTM function}
%---------------------------------------------------
\stepcounter{step}
At this point, much of the prepatory heavy lifting has been done. The CRTM function calls themselves are quite simple. For the forward model we do,
\begin{alltt}
  Error_Status = \hyperref[sec:CRTM_Forward_interface]{CRTM_Forward}( atm   , & ! Input
                               sfc   , & ! Input
                               gInfo , & ! Input
                               chInfo, & ! Input
                               rts     ) ! Output
  IF ( Error_Status /= SUCCESS ) THEN 
    \textrm{\textit{handle error...}}
  END IF\end{alltt}
and for the K-matrix model, the calling syntax is,
\begin{alltt}
  Error_Status = \hyperref[sec:CRTM_K_Matrix_interface]{CRTM_K_Matrix}( atm   , & ! Forward  input  
                                sfc   , & ! Forward  input    
                                rts_K , & ! K-matrix input    
                                gInfo , & ! Input  
                                chInfo, & ! Input  
                                atm_K , & ! K-matrix output
                                sfc_K , & ! K-matrix output  
                                rts     ) ! Forward  output
  IF ( Error_Status /= SUCCESS ) THEN 
    \textrm{\textit{handle error...}}
  END IF\end{alltt}
Note that the K-matrix model also returns the forward model radiances. The \hyperref[sec:CRTM_Tangent_Linear_interface]{tangent-linear} and \hyperref[sec:CRTM_Adjoint_interface]{adjoint} models have similar call structures and will not be shown here.


\subsection{Step 7: Destroy the CRTM and cleanup}
%------------------------------------------------
\stepcounter{step}
The last step is to cleanup. This involves calling the CRTM destruction function
\begin{alltt}
  Error_Status = \hyperref[sec:CRTM_Destroy_interface]{CRTM_Destroy}( chInfo )
  IF ( Error_Status /= SUCCESS ) THEN 
    \textrm{\textit{handle error...}}
  END IF\end{alltt}
to deallocate all the shared coefficient data, as well as calling the individual structure destroy functions to deallocate as required. For the example here, that entails deallocating the forward and K-matrix \hyperref[sec:atmosphere_structure]{\Atmosphere}  structures, \texttt{atm} and \texttt{atm\_K},
\begin{alltt}
  Error_Status = \hyperref[sec:CRTM_Destroy_Atmosphere_interface]{CRTM_Destroy_Atmosphere}(atm_K)
  IF ( Error_Status /= SUCCESS ) THEN 
    \textrm{\textit{handle error...}}
  END IF
  
  Error_Status = \hyperref[sec:CRTM_Destroy_Atmosphere_interface]{CRTM_Destroy_Atmosphere}(atm)
  IF ( Error_Status /= SUCCESS ) THEN 
    \textrm{\textit{handle error...}}
  END IF\end{alltt}


\section{Interface Descriptions}
%===============================

\input{fdoc/CRTM_Init}
\input{fdoc/CRTM_Forward}
\input{fdoc/CRTM_Tangent_Linear}
\input{fdoc/CRTM_Adjoint}
\input{fdoc/CRTM_K_Matrix}
\input{fdoc/CRTM_Destroy}


