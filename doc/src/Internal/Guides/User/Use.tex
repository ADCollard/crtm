\chapter{How to use the CRTM library}
%====================================
\section{Step by Step Guide}
%===========================
This section will hopefully get you started using the CRTM library as quickly as possible. Refer to the following sections for more information about the structures and interfaces.

Nearly all the examples shown here assume you are processing one sensor at a time. The CRTM can handle multiple sensors at once, but specifying the input information in a simple way is difficult; e.g. the GeometryInfo structure that is used to specify the sensor viewing geometry -- even sensors on the same platform typically have different numbers of fields-of-view (FOVs) per scan. For multiple sensor processing, we'll assume they will be separately processed in parallel.

Because there are many variations in what information is known ahead of time (and by ``ahead of time'' we mean at compile-time of your code), let's approach this via examples for fixed and variable numbers of atmospheric profiles, and known and unknown sensors. Different scenarios will be described indicating how the various CRTM structures should be declared and allocated, how the CRTM should be initialised, and how to call the forward and K-matrix models (use of the tangent-linear and adjoint models will be left as an exercise for the reader.) The scenarios are:\vspace{-2ex} 
\begin{enumerate}
  \item{Fixed number of atmospheric profiles; single \textit{known} sensor}
  \item{Variable number of atmospheric profiles; single \textit{known} sensor}
  \item{Fixed number of atmospheric profiles; single \textit{unknown} sensor}
  \item{Variable number of atmospheric profiles; multiple \textit{unknown} sensors}
\end{enumerate}
With regards to sensor identification, the CRTM uses a character string -- refered to as the \f{Sensor\_Id} -- to distinguish sensors and platforms. The lists of currently supported sensors, along with their associated \f{Sensor\_Id}'s, are shown in appendix \ref{sec:sensor_id}.


\newcounter{step}
\newcounter{example}[subsection]

\subsection{Step 1: Access the CRTM module}
%------------------------------------------
\stepcounter{step}
All of the CRTM user procedures, parameters, and derived data type definitions are accessible via the container module \f{CRTM\_Module}. Thus, one needs to put the following statement in any calling program, module or procedure,

\qquad\f{USE CRTM\_Module}

Once you become familiar with the components of the CRTM you require, you can also specify an \f{ONLY} clause with the \f{USE} statement,

\qquad\f{USE CRTM\_Module}[\f{, ONLY:}\textit{only-list}]

where \textit{only-list} is a list of the symbols you want to ``import'' from \f{CRTM\_Module}. This latter form is the preferred style for self-documenting your code; e.g. when you give the code to someone else, they will be able to identify from which module various symbols in your code originate.

\subsection{Step 2: Declare the CRTM structures}
%-----------------------------------------------
\refstepcounter{step}
\label{sec:declare_step}
To compute satellite radiances you need to declare structures for the following information,\vspace{-2ex}
\begin{enumerate}
  \item Atmospheric profile data such as pressure, temperature, absorber amounts, clouds, aerosols, etc. Handled using the \Atmosphere{} structure.
  \item Surface data such as type of surface, temperature, surface type specific parameters etc. Handled using the \Surface{} structure.
  \item Geometry information such as sensor scan angle, zenith angle, etc. Handled using the \GeometryInfo{} structure.
  \item Instrument information, particularly which instrument(s), or sensor(s)\footnote{The terms ``instrument'' and ``sensor'' are used interchangeably in this document.}, you want to simulate. Handled using the \ChannelInfo{} structure.
  \item Results of the radiative transfer calculation. Handled using the \RTSolution{} structure.
  \item Optional inputs. Handled using the \Options{} structure.
\end{enumerate}

\subsubsection{Example 1: Fixed number of profiles; single known sensor}
%.......................................................................
\refstepcounter{example}
\label{sec:declare_ex_fpsks}
Here let's assume you want to process, say, 50 profiles for the NOAA-18 AMSU-A sensor. That's a total of 15 channels. 
\begin{alltt}
  ! Processing parameters
  INTEGER, PARAMETER :: N_SENSORS  =  1
  INTEGER, PARAMETER :: N_CHANNELS = 15
  INTEGER, PARAMETER :: N_PROFILES = 50
  CHARACTER(*), PARAMETER :: SID(N_SENSORS) = (/'amsua_n18'/)
  ! Declarations
  TYPE(CRTM_Atmosphere_type)   :: atm(N_PROFILES)
  TYPE(CRTM_Surface_type)      :: sfc(N_PROFILES)
  TYPE(CRTM_GeometryInfo_type) :: gInfo(N_PROFILES)  
  TYPE(CRTM_ChannelInfo_type)  :: chInfo(N_SENSORS)  
  TYPE(CRTM_RTSolution_type)   :: rts(N_CHANNELS,N_PROFILES)\end{alltt}

The point we want to make here is that if you know how many channels you will be processing ahead of time, you can explicitly declare the sizes of the various structure arrays.

\subsubsection{Example 2: Variable number of profiles; single known sensor}
%..........................................................................
\refstepcounter{example}
\label{sec:declare_ex_vpsks}
Say you want to process the same instrument as the previous example, but you don't know ahead of time how many profiles you will be processing. In this case you will need to declare any profile-dependent arguments with the \f{ALLOCATABLE} attribute,
\begin{alltt}
  ! Processing parameters
  INTEGER, PARAMETER :: N_SENSORS  =  1
  INTEGER, PARAMETER :: N_CHANNELS = 15
  CHARACTER(*), PARAMETER :: SID(N_SENSORS) = (/'amsua_n18'/)
  ! Declarations
  TYPE(CRTM_Atmosphere_type)  , ALLOCATABLE :: atm(:)
  TYPE(CRTM_Surface_type)     , ALLOCATABLE :: sfc(:)
  TYPE(CRTM_GeometryInfo_type), ALLOCATABLE :: gInfo(:)  
  TYPE(CRTM_ChannelInfo_type)               :: chInfo(N_SENSORS)
  TYPE(CRTM_RTSolution_type)  , ALLOCATABLE :: rts(:,:)\end{alltt}


\subsubsection{Example 3: Fixed number of profiles; single unknown sensor}
%.........................................................................
\refstepcounter{example}
\label{sec:declare_ex_fpsus}
Let's assume you'll be serially processing multiple sensors for a fixed number of profiles. What this means is that you don't necessarily know the number of channels since they are typically different for different sensors. This means that the RTSolution argument, \f{rts}, has an unknown dimension (the number of channels) and must be declared with the \f{ALLOCATABLE} attribute,
\begin{alltt}
  ! Processing parameters
  INTEGER, PARAMETER :: N_SENSORS  =  1
  INTEGER, PARAMETER :: N_PROFILES = 50
  ! Declarations
  CHARACTER(STRLEN)                       :: sId(N_SENSORS)
  TYPE(CRTM_Atmosphere_type)              :: atm(N_PROFILES)
  TYPE(CRTM_Surface_type)                 :: sfc(N_PROFILES)
  TYPE(CRTM_GeometryInfo_type)            :: gInfo(N_PROFILES)
  TYPE(CRTM_ChannelInfo_type)             :: chInfo(N_SENSORS)
  TYPE(CRTM_RTSolution_type), ALLOCATABLE :: rts(:,:)\end{alltt}

Note the use of the parameter \f{STRLEN} in the declaration of the Sensor Id argument, \f{sId}. This character length definition is inherited from the \f{CRTM\_Module} and is used throughout the CRTM as the length of the Sensor Id string. Currently it's value is 20, but that could change in the future; suffice it to say you should use the \f{STRLEN} parameter for Sensor Id character string declarations. 

\subsubsection{Example 4: Variable number of profiles; multiple unknown sensors}
%...............................................................................
\refstepcounter{example}
\label{sec:declare_ex_vpmus}
This is a bit of a ``cover all your bases'' example, where we'll assume you'll be processing a variable number of profiles for an unknown number of sensors \textit{in parallel}\footnote{It doesn't make sense to process multiple sensors simultaneously in the same CRTM function call since each sensor will have more than likely have different viewing geometries even if their fields-of-view (FOVs) correspond geographically.}. This simply means everything is declared with the \f{ALLOCATABLE} attribute,
\begin{ttfamily}
  \begin{alltt}
  ! Declarations
  CHARACTER(STRLEN)           , ALLOCATABLE :: sId(:)
  TYPE(CRTM_Atmosphere_type)  , ALLOCATABLE :: atm(:)
  TYPE(CRTM_Surface_type)     , ALLOCATABLE :: sfc(:)
  TYPE(CRTM_GeometryInfo_type), ALLOCATABLE :: gInfo(:)  
  TYPE(CRTM_ChannelInfo_type) , ALLOCATABLE :: chInfo(:)
  TYPE(CRTM_RTSolution_type)  , ALLOCATABLE :: rts(:,:)\end{alltt}
\end{ttfamily}




\subsection{Step 3: Initialise the CRTM}
%---------------------------------------
\stepcounter{step}
\label{sec:init_step}
The CRTM is initialised by calling the \f{CRTM\_Init()} function in the \f{CRTM\_LifeCycle.f90} module. This loads all the various coefficient data used by CRTM components into memory for later use. We'll assume that all the required datafiles reside in the subdirectory \f{./coeff\_data} and follow on from the examples of Step \ref{sec:declare_step}. The CRTM initialisation is profile independent, so we're only dealing with sensor variability here.

\subsubsection{Example 1: Fixed number of sensors}
%.................................................
\refstepcounter{example}
\label{sec:init_ex_fns}
Here you're using the ChannelInfo and Sensor Id arrays as declared in examples \ref{sec:declare_ex_fpsks} through \ref{sec:declare_ex_fpsus} of Step \ref{sec:declare_step},
\begin{alltt}
  CHARACTER(*), PARAMETER :: PROGRAM_NAME='My Program Name'
  INTEGER :: errStatus
  ....
  errStatus = CRTM_Init( chInfo, Sensor_Id=SID, File_Path='./coeff_data' )
  IF ( errStatus /= SUCCESS ) THEN 
    CALL Display_Message( PROGRAM_NAME,'Error initializing CRTM',errStatus )
    STOP
  END IF\end{alltt}

Here we see for the first time how the CRTM functions let you know if they were successful. As you can see the \f{CRTM\_Init()} function result is an error status that is checked against a parameterised error code, \f{SUCCESS}. Other available error code parameters are \f{FAILURE}, \f{WARNING}, and \f{INFORMATION} -- although the latter is never used as a function result. Note that you don't \textit{have} to call the error message handler subroutine \f{Display\_Message}, it just outputs messages in a standard way (see appendix \ref{sec:utility_message_handler}) and is used throughout the CRTM code.

\subsubsection{Example 2: Variable number of sensors}
%....................................................
\refstepcounter{example}
\label{sec:init_ex_vns}
This example follows on from example \ref{sec:declare_ex_vpmus} of Step \ref{sec:declare_step}. For this sort of usage you will need to allocate the ChannelInfo and Sensor Id arguments to the number of sensors you wish to process as well as fill it. For illustrative purposes only, let's assume your calling program requires you to simply type in the number and list of sensors,
\begin{alltt}
  CHARACTER(256) :: Message
  INTEGER :: n, n_Sensors
  ....
  ! Allocate the channelInfo and Sensor Id array
  READ( *,'(/2x,"Enter the number of sensors to process: ")', ADVANCE="NO" ) n_Sensors
  ALLOCATE( chInfo(n_Sensors), sId(n_Sensors), STAT=errStatus )
  IF ( errStatus /= 0 ) THEN
    WRITE( Message,'("Error allocating the chInfo and sId arrays. STAT=",i0)' ) errStatus
    CALL Display_Message( PROGRAM_NAME,TRIM(Message),FAILURE )
    STOP
  END IF
  
  ! Get user sensor id input
  DO n = 1, n_Sensors
    READ( *,'(4x,"Enter sensor id #",i0,": ")', ADVANCE="NO" ) sId(n)
  END DO
  
  ! Initialise the CRTM for the dynamic sensor list
  errStatus = CRTM_Init( chInfo, Sensor_Id=sId, File_Path='./coeff_data' )
  IF ( errStatus /= SUCCESS ) THEN 
    CALL Display_Message( PROGRAM_NAME,'Error initializing CRTM',errStatus )
    STOP
  END IF\end{alltt}

This is, of course, a rather contrived example since it is guaranteed that typing in sensor identifiers by hand will get quite annoying very quickly.

One thing to note in the above example is the use of the error status variable \f{errStatus} for both standard errors (e.g. the allocation \f{STAT} result) and CRTM errors. In the former case, \f{errStatus} doesn't have any meaning for the \f{Display\_Message} subroutine\footnote{Indeed, the actual values of standard error codes can vary widely not only with the cause of the error, but also with compiler, operating system, and combinations thereof.}, hence the use of the actual fail parameter \f{FAILURE} in the call.


\subsection{Step 4: Allocate the CRTM structure arrays}
%------------------------------------------------------
\stepcounter{step}
\label{sec:alloc_arr_step}
If you've declared everything for a fixed number of profiles and sensors/channels (e.g. as shown in example \ref{sec:declare_ex_fpsks} of Step \ref{sec:declare_step}), then you can skip to the next step. Here we will allocate the various CRTM structure \textit{arrays} (not the structures themselves -- the distinction is important) to the required size.

\subsubsection{Example 1: Variable number of profiles; single known sensor}
%..........................................................................
\refstepcounter{example}
\label{sec:alloc_arr_ex_vpsks}
The following allocations apply to the declarations shown in example \ref{sec:declare_ex_vpsks} of step \ref{sec:declare_step}, where the \f{N\_CHANNELS} parameter is declared. For simplicity, we'll assume the number of profiles to process is entered by a user, but it would more likely be read from a file or passed as an argument, etc.
\begin{alltt}
  INTEGER :: n_Profiles
  ....
  ! Determine the number of profiles to process
  READ( *,'(/2x,"Enter the number of profiles to process: ")', ADVANCE="NO" ) n_Profiles
  
  ! Allocate the structure arrays
  ALLOCATE( atm(n_Profiles), &
            sfc(n_Profiles), &
            gInfo(n_Profiles), &
            rts(N_CHANNELS, n_Profiles), &
            STAT=errStatus )
  IF ( errStatus /= 0 ) THEN 
    WRITE( Message,'("Error allocating the structure arrays. STAT=",i0)' ) errStatus
    CALL Display_Message( PROGRAM_NAME,TRIM(Message),FAILURE )
    STOP
  END IF\end{alltt}


\subsubsection{Example 2: Fixed number of profiles; single unknown sensor}
%.........................................................................
\refstepcounter{example}
\label{sec:alloc_arr_ex_fpsus}
Here the only unknown is the number of channels since the sensor is ``unknown'' at compile time, as shown in example \ref{sec:declare_ex_fpsus} of Step \ref{sec:declare_step}. Thus only the RTSolution argument needs allocating, but using the number of channels determined from the initialisation step,
\begin{alltt}
  INTEGER :: n_Profiles
  ....
  ! Allocate the structure arrays
  ALLOCATE( \textcolor{blue}{rts(chInfo(1)%n_Channels}, n_Profiles), &
            STAT=errStatus )
  IF ( errStatus /= 0 ) THEN 
    WRITE( Message,'("Error allocating the structure arrays. STAT=",i0)' ) errStatus
    CALL Display_Message( PROGRAM_NAME, &
                          TRIM(Message), & 
                          FAILURE )
    STOP
  END IF\end{alltt}

The ChannelInfo structure contains the number of sensor channels (see appendix \ref{sec:channelinfo_structure} for its full definition). The only thing to point out here is that even though we are only processing a single sensor, we still have to indicate the \f{chInfo} element for that sensor, \f{chInfo(1)}, when accessing the number of channel component.


\subsubsection{Example 3: Variable number of profiles; multiple unknown sensors}
%...............................................................................
\refstepcounter{example}
\label{sec:alloc_arr_ex_vpmus}
Here everything is unknown. Note how the total number of channels is obtained in the example source code,
\begin{alltt}
  INTEGER :: n_Channels
  ....
  ! Determine the total number of channels for all the sensors
  \textcolor{blue}{n_Channels = SUM(chInfo%n_Channels)}
  
  ! Determine the number of profiles to process
  READ( *,'(/2x,"Enter the number of profiles to process: ")', ADVANCE="NO" ) n_Profiles
  
  ! Allocate the structure arrays
  ALLOCATE( atm(n_Profiles), &
            sfc(n_Profiles), &
            gInfo(n_Profiles), &
            rts(n_Channels, n_Profiles), &
            STAT=errStatus )
  IF ( errStatus /= 0 ) THEN 
    WRITE( Message,'("Error allocating the structure arrays. STAT=",i0)' ) errStatus
    CALL Display_Message( PROGRAM_NAME, &
                          TRIM(Message), & 
                          FAILURE )
    STOP
  END IF\end{alltt}


\subsection{Step 5: Allocate the CRTM structures}
%------------------------------------------------
\stepcounter{step}
The previous step involved allocating the structure arrays for the required number of profiles, channels, and/or sensors. This step involves the allocation of the \emph{internal} structure components where necessary to hold the input or output data. In this case, functions are used to perform these ``internal'' allocations. The function naming convention is \f{CRTM\_Allocate\_}\textit{name} where, for typical usage, the CRTM structures that need to be allocated are the Atmosphere, RTSolution and, if used, Options structures. 

\subsubsection{Example 1: Variable number of profiles; single known sensor}
%..........................................................................
\refstepcounter{example}
The following structure allocations follow the array allocations of example \ref{sec:alloc_arr_ex_vpsks} in step \ref{sec:alloc_arr_step}, where the \f{N\_CHANNELS} parameter is declared and the number of profiles is user-specified. The following assumes you'll want to allocate all the structures. First, we'll allocate the atmosphere structure to the required dimensions, like so:
\begin{alltt}
  ! Allocate the atmosphere structure
  errStatus = CRTM_Allocate_Atmosphere( n_Layers   , &  ! Input
                                        N_ABSORBERS, &  ! Input (always 2)
                                        n_Clouds   , &  ! Input
                                        n_Aerosols , &  ! Input
                                        atm          )  ! Output
  IF ( errStatus /= SUCCESS ) THEN 
    CALL Display_Message( PROGRAM_NAME, &
                          'Error allocating the atmosphere structure', & 
                          FAILURE )
    STOP
  END IF\end{alltt}
Note that the number of absorbers is in all capitals. In the CRTM, this style convention indicates a parameter. A parameter is used for the number of absorbers in the current CRTM release because the number of absorbers is fixed at two: water vapour and ozone. Future CRTM releases will allow more flexibility in selecting the number of absorbers, but currently the number must be set to two.

If 










\subsection{Step 6: Fill the CRTM input structures with data}
%------------------------------------------------------------
\stepcounter{step}


\subsection{Step 7: Call the required CRTM function}
%---------------------------------------------------
\stepcounter{step}


\subsection{Step 8: Destroy the CRTM}
%------------------------------------
\stepcounter{step}



\section{Interface Descriptions}
%===============================

\subsection{CRTM Initialisation}
%-------------------------------

\begin{figure}[htp]
  \centering
  \doublebox{
  \begin{minipage}[b]{6.5in}
    \begin{alltt}
  FUNCTION CRTM_Init( ChannelInfo      , &
                      Sensor_ID        , &
                      CloudCoeff_File  , &
                      AerosolCoeff_File, &
                      EmisCoeff_File   , &
                      File_Path        , &
                      Quiet            , &
                      Process_ID       , &
                      Output_Process_ID, &
                      RCS_Id           , &
                      Message_Log      ) &
                    RESULT( Error_Status )
    ! Arguments
    TYPE(CRTM_ChannelInfo_type), INTENT(IN OUT) :: ChannelInfo(:)
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: Sensor_ID(:)
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: CloudCoeff_File
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: AerosolCoeff_File
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: EmisCoeff_File
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: File_Path
    INTEGER     ,      OPTIONAL, INTENT(IN)     :: Quiet
    INTEGER     ,      OPTIONAL, INTENT(IN)     :: Process_ID
    INTEGER     ,      OPTIONAL, INTENT(IN)     :: Output_Process_ID
    CHARACTER(*),      OPTIONAL, INTENT(OUT)    :: RCS_Id
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: Message_Log
    ! Function result
    INTEGER :: Error_Status
    \end{alltt}
    \centering
    \begin{tabular}{p{3.25cm} p{6.5cm} p{1.75cm} p{2.5cm}}
      \hline
      \tblhd{Argument}             & \tblhd{Description}                             & \tblhd{Rank} & \tblhd{Intent} \\
      \hline\hline
      \f{ChannelInfo}              & Sensor and channel info structure               & $N$          & Output \\
      \optarg{Sensor\_Id}          & \textit{Sensor identification string}           & $N$          & \textit{Input}  \\
      \optarg{CloudCoeff\_File}    & \textit{Cloud optical property LUT filename}    & Scalar       & \textit{Input}  \\
      \optarg{AerosolCoeff\_File}  & \textit{Aerosol optical property LUT filename}  & Scalar       & \textit{Input}  \\
      \optarg{EmisCoeff\_File}     & \textit{IR sea surface emissivity LUT filename} & Scalar       & \textit{Input}  \\
      \optarg{File\_Path}          & \textit{Path to *Coeff files}                   & Scalar       & \textit{Input}  \\
      \optarg{Quiet}               & \textit{Keyword to control info message output} & Scalar       & \textit{Input}  \\
      \optarg{Process\_Id}         & \textit{MPI process Id}                         & Scalar       & \textit{Input}  \\
      \optarg{Output\_Process\_Id} & \textit{MPI process Id for message output}      & Scalar       & \textit{Input}  \\
      \optarg{RCS\_Id}             & \textit{Version control ID for the module}      & Scalar       & \textit{Output} \\
      \optarg{Message\_Log}        & \textit{Log message filename}                   & Scalar       & \textit{Input} 
    \end{tabular}
  \end{minipage}
  }
  \caption{CRTM Initialisation interface and argument description.}
  \label{fig:init_interface}
\end{figure}

\subsection{Forward Model}
%-------------------------

\begin{figure}[htp]
  \centering
  \doublebox{
  \begin{minipage}[b]{6.5in}
    \begin{alltt}
  FUNCTION CRTM_Forward( Atmosphere  , &
                         Surface     , &
                         GeometryInfo, &
                         ChannelInfo , &
                         RTSolution  , &
                         Options     , &    
                         RCS_Id      , &
                         Message_Log ) &
                       RESULT( Error_Status )
    ! Arguments
    TYPE(CRTM_Atmosphere_type),        INTENT(IN)     :: Atmosphere(:)
    TYPE(CRTM_Surface_type),           INTENT(IN)     :: Surface(:)
    TYPE(CRTM_GeometryInfo_type),      INTENT(IN OUT) :: GeometryInfo(:)
    TYPE(CRTM_ChannelInfo_type),       INTENT(IN)     :: ChannelInfo(:)
    TYPE(CRTM_RTSolution_type),        INTENT(IN OUT) :: RTSolution(:,:)
    TYPE(CRTM_Options_type), OPTIONAL, INTENT(IN)     :: Options(:)
    CHARACTER(*),            OPTIONAL, INTENT(OUT)    :: RCS_Id
    CHARACTER(*),            OPTIONAL, INTENT(IN)     :: Message_Log
    ! Function result
    INTEGER :: Error_Status
    \end{alltt}
    \centering
    \begin{tabular}{p{3.25cm} p{6.5cm} p{1.75cm} p{2.5cm}}
      \hline
      \tblhd{Argument}       & \tblhd{Description}                           & \tblhd{Rank} & \tblhd{Intent} \\
      \hline\hline
      \f{Atmosphere}         & Atmospheric state                             & $M$          & Input  \\
      \f{Surface}            & Surface state                                 & $M$          & Input  \\
      \f{GeometryInfo}       & Geometry information (e.g. angles)            & $M$          & Input  \\
      \f{ChannelInfo}        & Sensor channel information                    & $N$          & Input  \\
      \f{RTSolution}         & Radiative transfer solution                   & $L \times M$ & Output \\
      \optarg{Options}       & \textit{Structure containing optional inputs} & $M$          & \textit{Input}  \\
      \optarg{RCS\_Id}       & \textit{Version control ID for the module}    & Scalar       & \textit{Output} \\
      \optarg{Message\_Log}  & \textit{Log message filename}                 & Scalar       & \textit{Input} 
    \end{tabular}
  \end{minipage}
  }
  \caption{CRTM Forward model interface and argument description.}
  \label{fig:fwd_interface}
\end{figure}


\subsection{K-Matrix Model}
%--------------------------

\begin{figure}[htp]
  \centering
  \doublebox{
  \begin{minipage}[b]{6.5in}
    \begin{alltt}
  FUNCTION CRTM_K_Matrix( Atmosphere  , &
                          Surface     , &
                          RTSolution_K, &
                          GeometryInfo, &
                          ChannelInfo , &
                          Atmosphere_K, &
                          Surface_K   , &
                          RTSolution  , &
                          Options     , &
                          RCS_Id      , &
                          Message_Log ) &
                        RESULT( Error_Status )
    ! Arguments
    TYPE(CRTM_Atmosphere_type)       , INTENT(IN)     :: Atmosphere(:)
    TYPE(CRTM_Surface_type)          , INTENT(IN)     :: Surface(:)
    TYPE(CRTM_RTSolution_type)       , INTENT(IN OUT) :: RTSolution_K(:,:)
    TYPE(CRTM_GeometryInfo_type)     , INTENT(IN OUT) :: GeometryInfo(:)
    TYPE(CRTM_ChannelInfo_type)      , INTENT(IN)     :: ChannelInfo(:)
    TYPE(CRTM_Atmosphere_type)       , INTENT(IN OUT) :: Atmosphere_K(:,:)
    TYPE(CRTM_Surface_type)          , INTENT(IN OUT) :: Surface_K(:,:)
    TYPE(CRTM_RTSolution_type)       , INTENT(IN OUT) :: RTSolution(:,:)
    TYPE(CRTM_Options_type), OPTIONAL, INTENT(IN)     :: Options(:)
    CHARACTER(*),            OPTIONAL, INTENT(OUT)    :: RCS_Id
    CHARACTER(*),            OPTIONAL, INTENT(IN)     :: Message_Log
    ! Function result
    INTEGER :: Error_Status
    \end{alltt}
    \centering
    \begin{tabular}{p{3.25cm} p{6.5cm} p{1.75cm} p{2.5cm}}
      \hline
      \tblhd{Argument}      & \tblhd{Description}                           & \tblhd{Rank} & \tblhd{Intent} \\
      \hline\hline
      \f{Atmosphere}        & Atmospheric state                             & $M$          & FWD Input  \\
      \f{Surface}           & Surface state                                 & $M$          & FWD Input  \\
      \f{RTSolution\_K}     & Adjoint radiative transfer solution           & $L \times M$ & K   Input  \\
      \f{GeometryInfo}      & Geometry information (e.g. angles)            & $M$          & Input      \\
      \f{ChannelInfo}       & Sensor channel information                    & $N$          & Input      \\
      \f{Atmosphere\_K}     & Atmospheric state Jacobians                   & $L \times M$ & K   Output \\
      \f{Surface\_K}        & Surface state Jacobians                       & $L \times M$ & K   Output \\
      \f{RTSolution}        & Radiative transfer solution                   & $L \times M$ & FWD Output \\
      \optarg{Options}      & \textit{Structure containing optional inputs} & $M$          & \textit{Input}  \\
      \optarg{RCS\_Id}      & \textit{Version control ID for the module}    & Scalar       & \textit{Output} \\
      \optarg{Message\_Log} & \textit{Log message filename}                 & Scalar       & \textit{Input} 
    \end{tabular}
  \end{minipage}
  }
  \caption{CRTM K-Matrix model interface and argument description.}
  \label{fig:k_interface}
\end{figure}


\subsection{CRTM Destruction}
%----------------------------

\begin{figure}[htp]
  \centering
  \doublebox{
  \begin{minipage}[b]{16.5cm}
    \begin{alltt}
  FUNCTION CRTM_Destroy( ChannelInfo , &  ! Output
                         Process_ID  , &  ! Optional input
                         RCS_Id      , &  ! Revision control
                         Message_Log ) &  ! Error messaging
                       RESULT ( Error_Status )
    ! Arguments
    TYPE(CRTM_ChannelInfo_type), INTENT(IN OUT) :: ChannelInfo(:)
    INTEGER     ,      OPTIONAL, INTENT(IN)     :: Process_ID
    CHARACTER(*),      OPTIONAL, INTENT(OUT)    :: RCS_Id
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: Message_Log
    ! Function result
    INTEGER :: Error_Status
    \end{alltt}
    \centering
    \begin{tabular}{p{3.25cm} p{6.5cm} p{1.75cm} p{2.5cm}}
      \hline
      \tblhd{Argument}      & \tblhd{Description}                           & \tblhd{Rank} & \tblhd{Intent} \\
      \hline\hline
      \f{ChannelInfo}       & Sensor and channel info structure             & $N$          & In/Output       \\
      \optarg{Process\_Id}  & \textit{MPI process Id}                       & Scalar       & \textit{Input}  \\
      \optarg{RCS\_Id}      & \textit{Version control ID for the module}    & Scalar       & \textit{Output} \\
      \optarg{Message\_Log} & \textit{Log message filename}                 & Scalar       & \textit{Input} 
    \end{tabular}
  \end{minipage}
  }
  \caption{CRTM Destruction interface and argument description.}
  \label{fig:destroy_interface}
\end{figure}


\section{Filling input data structures}
%======================================

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/sensor_scan_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} sensor scan angle component.}
  \label{fig:gInfo_sensor_scan_angle}
\end{figure}

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/sensor_zenith_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} sensor zenith angle component.}
  \label{fig:gInfo_sensor_zenith_angle}
\end{figure}

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/sensor_azimuth_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} sensor azimuth angle component.}
  \label{fig:gInfo_sensor_azimuth_angle}
\end{figure}

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/source_zenith_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} source zenith angle component.}
  \label{fig:gInfo_source_zenith_angle}
\end{figure}

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/source_azimuth_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} source azimuth angle component.}
  \label{fig:gInfo_source_azimuth_angle}
\end{figure}
