\chapter{How to use the CRTM library}
%====================================
\section{Quick Start}
%====================
This section will hopefully get you started using the CRTM library as quickly as possible. Refer to the following sections for more information about the structures and interfaces.

Assumptions:
All examples here will assume you are processing 1 sensor at a time. the crtm can handle multiple sensors at once, but specifying the input information in a simple way is difficult (e.g. geometryinfo - sensors on the same platform typical have different numbers of FOVs/scan.


Need to alter the example below.

The first thing you need to do is identify what sensors you want to use. The list of supported sensors, along with their associated \f{Sensor\_Id}'s, are shown in appendix BLAH



\subsection{Step 1: Access the CRTM module}
%------------------------------------------
All of the CRTM user procedures, parameters, and derived data types are accessible via the container module \f{CRTM\_Module}. Thus, one needs to put the following statement in any calling program, module or procedure,

\qquad\f{USE CRTM\_Module}

If you're very familiar with the components of the CRTM you require, you can also specify an \f{ONLY} clause with the \f{USE} statement,

\qquad\f{USE CRTM\_Module}[\f{, ONLY:}\textit{only-list}]

where \textit{only-list} is a list of the symbols you want to ``import'' from \f{CRTM\_Module}. This latter form is the preferred style for self-documenting your code; e.g. when you give the code to someone else, they will be able to identify from which module various symbols in your code originate.

\subsection{Step 2: Declare the CRTM structures}
%-----------------------------------------------
To compute satellite radiances you need to declare structures for the following information,
\begin{enumerate}
  \item Atmospheric profile data such as pressure, temperature, absorber amounts, clouds, aerosols, etc. Handled using the \Atmosphere{} structure.
  \item Surface data such as type of surface, temperature, surface type specific parameters etc. Handled using the \Surface{} structure.
  \item Geometry information such as sensor scan angle, zenith angle, etc. Handled using the \GeometryInfo{} structure.
  \item Instrument information, particularly which instrument(s) you want to simulate. Handled using the \ChannelInfo{} structure.
  \item Results of the radiative transfer calculation. Handled using the \RTSolution{} structure.
\end{enumerate}
Because there are many variations in what information is known ahead of time (and by ``ahead of time'' I mean at compile-time of your code), let's approach this via examples.

\subsubsection{Example 1: Fixed number of profiles \textbf{and} sensors}
Here we'll assume you want to process, say, 50 profiles for three sensors: NOAA-18 HIRS/4, AMSU-A, and MHS. That's a total of 39 channels. For simplicity, we'll also assume that the fields-of-view (FOVs) of the various sensors coincide (which is not true).
\begin{ttfamily}
  \begin{verbatim}
  ! Processing parameters
  INTEGER, PARAMETER :: N_PROFILES = 50
  INTEGER, PARAMETER :: N_CHANNELS = 39
  INTEGER, PARAMETER :: N_SENSORS  =  3
  CHARACTER(*), PARAMETER :: SENSOR_ID(N_SENSORS) = (/'hirs4_n18',&
                                                      'amsua_n18',&
                                                      'mhs_n18  '/)
  ! Structure array definitions
  TYPE(CRTM_Atmosphere_type)   :: atm(N_PROFILES)
  TYPE(CRTM_Surface_type)      :: sfc(N_PROFILES)
  TYPE(CRTM_GeometryInfo_type) :: gInfo(N_PROFILES)  
  TYPE(CRTM_ChannelInfo_type)  :: chInfo(N_SENSORS)  
  TYPE(CRTM_RTSolution_type)   :: rts(N_CHANNELS,N_PROFILES)\end{verbatim}
\end{ttfamily}
The point I want to make here is that we know how many channels we will be processing ahead of time, hence we can declare the sizes of the various structure arrays.

\subsubsection{Example 2: Fixed number of profiles, but variable number of sensors}
If you don't know ahead of time which sensors you will be processing at any particular time, then you don't know the number of sensors and channels. You can handle this by using the \f{ALLOCATABLE} attribute for those arrays whose dimensions are unknown at compile-time,
\begin{ttfamily}
  \begin{verbatim}
  ! Processing parameters
  INTEGER, PARAMETER :: N_PROFILES = 50

  ! Sensor Id definition
  CHARACTER(STRLEN), ALLOCATABLE :: Sensor_Id(:) ! n_Sensors dimension
  ! Structure array definitions
  TYPE(CRTM_Atmosphere_type)   :: atm(N_PROFILES)
  TYPE(CRTM_Surface_type)      :: sfc(N_PROFILES)
  TYPE(CRTM_GeometryInfo_type) :: gInfo(N_PROFILES)  
  TYPE(CRTM_ChannelInfo_type), ALLOCATABLE :: chInfo(:) ! n_Sensors dimension
  TYPE(CRTM_RTSolution_type),  ALLOCATABLE :: rts(:,:)  ! n_Channels x n_Profiles\end{verbatim}
\end{ttfamily}




\subsection{Step 3: Initialise the CRTM}
%---------------------------------------

\subsection{Step 4: Allocate the CRTM structures}
%------------------------------------------------

\subsection{Step 5: Fill the CRTM input structures with data}
%------------------------------------------------------------

\subsection{Step 6: Call the required cRTM function}
%---------------------------------------------------

\subsection{Step 7: Destroy the CRTM}
%------------------------------------


\section{Interface Descriptions}
%===============================

\subsection{CRTM Initialisation}
%-------------------------------

\begin{figure}[htp]
  \centering
  \doublebox{
  \begin{minipage}[b]{6.5in}
    \begin{ttfamily}
      \begin{verbatim}
  FUNCTION CRTM_Init( ChannelInfo      , &  ! Output, N
                      Sensor_ID        , &  ! Optional input, N
                      CloudCoeff_File  , &  ! Optional input
                      AerosolCoeff_File, &  ! Optional input
                      EmisCoeff_File   , &  ! Optional input
                      File_Path        , &  ! Optional input
                      Quiet            , &  ! Optional input
                      Process_ID       , &  ! Optional input
                      Output_Process_ID, &  ! Optional input
                      RCS_Id           , &  ! Revision control
                      Message_Log      ) &  ! Error messaging
                    RESULT( Error_Status )

    ! Arguments
    TYPE(CRTM_ChannelInfo_type), INTENT(IN OUT) :: ChannelInfo(:)  ! N
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: Sensor_ID(:)    ! N
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: CloudCoeff_File
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: AerosolCoeff_File
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: EmisCoeff_File
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: File_Path
    INTEGER     ,      OPTIONAL, INTENT(IN)     :: Quiet
    INTEGER     ,      OPTIONAL, INTENT(IN)     :: Process_ID
    INTEGER     ,      OPTIONAL, INTENT(IN)     :: Output_Process_ID
    CHARACTER(*),      OPTIONAL, INTENT(OUT)    :: RCS_Id
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: Message_Log
    ! Function result
    INTEGER :: Error_Status
      \end{verbatim}
    \end{ttfamily}
    \centering
    \begin{tabular}{c|c|c|c}
      \textbf{Argument} & \textbf{Description}                     & \textbf{Rank}   & \textbf{Intent} \\
      \hline\hline
      ChannelInfo        & Sensor and channel info structure       & n\_Sensors (N)  & IN OUT      \\
      \hline
      Sensor\_Id         & Sensor identification string            & n\_Sensors (N)  & IN      \\
      \hline
      CloudCoeff\_File   & Cloud optical property LUT filename     & Scalar          & IN      \\
      \hline
      AerosolCoeff\_File & Aerosol optical property LUT filename   & Scalar          & IN      \\
      \hline
      EmisCoeff\_File    & IR sea surface emissivity LUT filename  & Scalar          & IN      \\
      \hline
      File\_Path         & Path to *Coeff files                    & Scalar          & IN      \\
      \hline
      Quiet              & Keyword to control information message output & Scalar         & IN      \\
      \hline
      Process\_Id        & MPI process Id                          & Scalar          & IN      \\
      \hline
      Output\_Process\_Id & MPI process Id for message output      & Scalar          & IN      \\
      \hline
      RCS\_Id            & Version control ID for the module      & Scalar           & OUT     \\
      \hline
      Message\_Log       & Log message filename                   & Scalar           & IN      \\
    \end{tabular}
  \end{minipage}
  }
  \caption{CRTM Initialisation interface and argument description.}
  \label{fig:init_interface}
\end{figure}

\subsection{Forward Model}
%-------------------------

\begin{figure}[htp]
  \centering
  \doublebox{
  \begin{minipage}[b]{6.5in}
    \begin{ttfamily}
      \begin{verbatim}
  FUNCTION CRTM_Forward( Atmosphere  , &  ! Input, M
                         Surface     , &  ! Input, M    
                         GeometryInfo, &  ! Input, M    
                         ChannelInfo , &  ! Input, N
                         RTSolution  , &  ! Output, L x M   
                         Options     , &  ! Optional input, M    
                         RCS_Id      , &  ! Revision control
                         Message_Log ) &  ! Error messaging
                       RESULT( Error_Status )
    ! Arguments
    TYPE(CRTM_Atmosphere_type),        INTENT(IN)     :: Atmosphere(:)     ! M
    TYPE(CRTM_Surface_type),           INTENT(IN)     :: Surface(:)        ! M
    TYPE(CRTM_GeometryInfo_type),      INTENT(IN OUT) :: GeometryInfo(:)   ! M
    TYPE(CRTM_ChannelInfo_type),       INTENT(IN)     :: ChannelInfo(:)    ! N 
    TYPE(CRTM_RTSolution_type),        INTENT(IN OUT) :: RTSolution(:,:)   ! L x M
    TYPE(CRTM_Options_type), OPTIONAL, INTENT(IN)     :: Options(:)        ! M
    CHARACTER(*),            OPTIONAL, INTENT(OUT)    :: RCS_Id
    CHARACTER(*),            OPTIONAL, INTENT(IN)     :: Message_Log
    ! Function result
    INTEGER :: Error_Status
      \end{verbatim}
    \end{ttfamily}
    \centering
    \begin{tabular}{c|c|c|c}
      \textbf{Argument} & \textbf{Description}                    & \textbf{Rank}    & \textbf{Intent} \\
      \hline\hline
      Atmosphere         & Atmospheric state                      & n\_Profiles (M)  & IN      \\
      \hline
      Surface            & Surface state                          & n\_Profiles (M)  & IN      \\
      \hline
      GeometryInfo       & Geometry information (e.g. angles)     & n\_Profiles (M)  & IN      \\
      \hline
      ChannelInfo        & Sensor channel information             & n\_Sensors (N)   & IN      \\
      \hline
      RTSolution         & Radiative transfer solution            & n\_Channels x n\_Profiles                 & IN OUT  \\
      \hline
      Options            & Structure for optional input           & n\_Profiles (M)  & IN      \\
      \hline
      RCS\_Id            & Version control ID for the module      & Scalar           & OUT     \\
      \hline
      Message\_Log       & Log message filename                   & Scalar           & IN      \\
    \end{tabular}
  \end{minipage}
  }
  \caption{CRTM Forward model interface and argument description.}
  \label{fig:fwd_interface}
\end{figure}


\subsection{K-Matrix Model}
%--------------------------

\begin{figure}[htp]
  \centering
  \doublebox{
  \begin{minipage}[b]{6.5in}
    \begin{ttfamily}
      \begin{verbatim}
  FUNCTION CRTM_K_Matrix( Atmosphere  , &  ! FWD Input, M
                          Surface     , &  ! FWD Input, M
                          RTSolution_K, &  ! K   Input, L x M   
                          GeometryInfo, &  ! Input, M
                          ChannelInfo , &  ! Input, N  
                          Atmosphere_K, &  ! K   Output, L x M
                          Surface_K   , &  ! K   Output, L x M
                          RTSolution  , &  ! FWD Output, L x M
                          Options     , &  ! Optional FWD input, M
                          RCS_Id      , &  ! Revision control
                          Message_Log ) &  ! Error messaging
                        RESULT( Error_Status )
    ! Arguments
    TYPE(CRTM_Atmosphere_type)       , INTENT(IN)     :: Atmosphere(:)     ! M
    TYPE(CRTM_Surface_type)          , INTENT(IN)     :: Surface(:)        ! M
    TYPE(CRTM_RTSolution_type)       , INTENT(IN OUT) :: RTSolution_K(:,:) ! L x M
    TYPE(CRTM_GeometryInfo_type)     , INTENT(IN OUT) :: GeometryInfo(:)   ! M
    TYPE(CRTM_ChannelInfo_type)      , INTENT(IN)     :: ChannelInfo(:)    ! N
    TYPE(CRTM_Atmosphere_type)       , INTENT(IN OUT) :: Atmosphere_K(:,:) ! L x M
    TYPE(CRTM_Surface_type)          , INTENT(IN OUT) :: Surface_K(:,:)    ! L x M
    TYPE(CRTM_RTSolution_type)       , INTENT(IN OUT) :: RTSolution(:,:)   ! L x M
    TYPE(CRTM_Options_type), OPTIONAL, INTENT(IN)     :: Options(:)        ! M
    CHARACTER(*),            OPTIONAL, INTENT(OUT)    :: RCS_Id
    CHARACTER(*),            OPTIONAL, INTENT(IN)     :: Message_Log
    ! Function result
    INTEGER :: Error_Status
      \end{verbatim}
    \end{ttfamily}
    \centering
    \begin{tabular}{c|c|c|c}
      \textbf{Argument} & \textbf{Description}                    & \textbf{Rank}    & \textbf{Intent} \\
      \hline\hline
      Atmosphere         & Atmospheric state                      & n\_Profiles (M)  & IN      \\
      \hline
      Surface            & Surface state                          & n\_Profiles (M)  & IN      \\
      \hline
      RTSolution\_K      & Adjoint radiative transfer solution    & n\_Channels (L) x n\_Profiles (M) & IN OUT  \\
      \hline
      GeometryInfo       & Geometry information (e.g. angles)     & n\_Profiles (M)  & IN      \\
      \hline
      ChannelInfo        & Sensor channel information             & n\_Sensors (N)   & IN      \\
      \hline
      Atmosphere\_K      & Atmospheric state Jacobians            & n\_Channels (L) x n\_Profiles (M) & IN OUT  \\
      \hline
      Surface\_K         & Surface state Jacobians                & n\_Channels (L) x n\_Profiles (M) & IN OUT  \\
      \hline
      RTSolution         & Radiative transfer solution            & n\_Channels (L) x n\_Profiles (M) & IN OUT      \\
      \hline
      Options            & Structure for optional input           & n\_Profiles (M)  & IN      \\
      \hline
      RCS\_Id            & Version control ID for the module      & Scalar           & OUT     \\
      \hline
      Message\_Log       & Log message filename                   & Scalar           & IN      \\
    \end{tabular}
  \end{minipage}
  }
  \caption{CRTM K-Matrix model interface and argument description.}
  \label{fig:k_interface}
\end{figure}


\subsection{CRTM Destruction}
%----------------------------

\begin{figure}[htp]
  \centering
  \doublebox{
  \begin{minipage}[b]{6.5in}
    \begin{ttfamily}
      \begin{verbatim}
  FUNCTION CRTM_Destroy( ChannelInfo , &  ! Output
                         Process_ID  , &  ! Optional input
                         RCS_Id      , &  ! Revision control
                         Message_Log ) &  ! Error messaging
                       RESULT ( Error_Status )
    ! Arguments
    TYPE(CRTM_ChannelInfo_type), INTENT(IN OUT) :: ChannelInfo(:)
    INTEGER     ,      OPTIONAL, INTENT(IN)     :: Process_ID
    CHARACTER(*),      OPTIONAL, INTENT(OUT)    :: RCS_Id
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: Message_Log
    ! Function result
    INTEGER :: Error_Status
      \end{verbatim}
    \end{ttfamily}
    \centering
    \begin{tabular}{c|c|c|c}
      \textbf{Argument} & \textbf{Description}                     & \textbf{Rank}   & \textbf{Intent} \\
      \hline\hline
      ChannelInfo        & Sensor and channel info structure       & n\_Sensors (N)  & IN OUT      \\
      \hline
      Process\_Id        & MPI process Id                          & Scalar          & IN      \\
      \hline
      RCS\_Id            & Version control ID for the module      & Scalar           & OUT     \\
      \hline
      Message\_Log       & Log message filename                   & Scalar           & IN      \\
    \end{tabular}
  \end{minipage}
  }
  \caption{CRTM Destruction interface and argument description.}
  \label{fig:destroy_interface}
\end{figure}


\section{Filling input data structures}
%======================================

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/sensor_scan_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} sensor scan angle component.}
  \label{fig:gInfo_sensor_scan_angle}
\end{figure}

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/sensor_zenith_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} sensor zenith angle component.}
  \label{fig:gInfo_sensor_zenith_angle}
\end{figure}

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/sensor_azimuth_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} sensor azimuth angle component.}
  \label{fig:gInfo_sensor_azimuth_angle}
\end{figure}

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/source_zenith_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} source zenith angle component.}
  \label{fig:gInfo_source_zenith_angle}
\end{figure}

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/source_azimuth_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} source azimuth angle component.}
  \label{fig:gInfo_source_azimuth_angle}
\end{figure}
