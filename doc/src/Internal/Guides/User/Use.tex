\chapter{How to use the CRTM library}
%====================================
\section{Step by Step Guide}
%===========================
This section will hopefully get you started using the CRTM library as quickly as possible. Refer to the following sections for more information about the structures and interfaces.

Assumptions:
All examples here will assume you are processing 1 sensor at a time. the crtm can handle multiple sensors at once, but specifying the input information in a simple way is difficult (e.g. geometryinfo - sensors on the same platform typical have different numbers of FOVs/scan. For multiple sensors, one assumes they will be separately processed in parallel


Need to alter the example below.

The first thing you need to do is identify what sensors you want to use. The list of supported sensors, along with their associated \f{Sensor\_Id}'s, are shown in appendix BLAH


\newcounter{step}
\newcounter{example}[subsection]

\subsection{Step 1: Access the CRTM module}
%------------------------------------------
\stepcounter{step}
All of the CRTM user procedures, parameters, and derived data types are accessible via the container module \f{CRTM\_Module}. Thus, one needs to put the following statement in any calling program, module or procedure,

\qquad\f{USE CRTM\_Module}

If you're very familiar with the components of the CRTM you require, you can also specify an \f{ONLY} clause with the \f{USE} statement,

\qquad\f{USE CRTM\_Module}[\f{, ONLY:}\textit{only-list}]

where \textit{only-list} is a list of the symbols you want to ``import'' from \f{CRTM\_Module}. This latter form is the preferred style for self-documenting your code; e.g. when you give the code to someone else, they will be able to identify from which module various symbols in your code originate.

\subsection{Step 2: Declare the CRTM structures}
%-----------------------------------------------
\refstepcounter{step}
\label{sec:declare_step}
To compute satellite radiances you need to declare structures for the following information,
\begin{enumerate}
  \item Atmospheric profile data such as pressure, temperature, absorber amounts, clouds, aerosols, etc. Handled using the \Atmosphere{} structure.
  \item Surface data such as type of surface, temperature, surface type specific parameters etc. Handled using the \Surface{} structure.
  \item Geometry information such as sensor scan angle, zenith angle, etc. Handled using the \GeometryInfo{} structure.
  \item Instrument information, particularly which instrument(s), or sensor(s)\footnote{The terms ``instrument'' and ``sensor'' are used interchangeably in this document.}, you want to simulate. Handled using the \ChannelInfo{} structure.
  \item Results of the radiative transfer calculation. Handled using the \RTSolution{} structure.
\end{enumerate}
Because there are many variations in what information is known ahead of time (and by ``ahead of time'' I mean at compile-time of your code), let's approach this via examples for a fixed and a variable number of atmospheric profiles.

\subsubsection{Example 1: Fixed number of profiles}
%..................................................
\refstepcounter{example}
\label{sec:declare_step_allfixed_ex}
Here we'll assume you want to process, say, 50 profiles for the NOAA-18 AMSU-A sensor. That's a total of 15 channels.
\begin{ttfamily}
  \begin{verbatim}
  ! Processing parameters
  INTEGER, PARAMETER :: N_SENSORS  =  1
  INTEGER, PARAMETER :: N_CHANNELS = 15
  INTEGER, PARAMETER :: N_PROFILES = 50
  CHARACTER(*), PARAMETER :: SID(N_SENSORS) = (/'amsua_n18'/)
  ! Declarations
  TYPE(CRTM_Atmosphere_type)   :: atm(N_PROFILES)
  TYPE(CRTM_Surface_type)      :: sfc(N_PROFILES)
  TYPE(CRTM_GeometryInfo_type) :: gInfo(N_PROFILES)  
  TYPE(CRTM_ChannelInfo_type)  :: chInfo(N_SENSORS)  
  TYPE(CRTM_RTSolution_type)   :: rts(N_CHANNELS,N_PROFILES)\end{verbatim}
\end{ttfamily}
The point I want to make here is that we know how many channels we will be processing ahead of time, hence we can declare the sizes of the various structure arrays.

\subsubsection{Example 2: Variable number of profiles}
%.....................................................
\refstepcounter{example}
\label{sec:declare_step_varprof_ex}
Say you want to process the same instrument as the previous example, but you don't know ahead of time how many profiles you will be processing. In this case you will need to define any profile-dependent arguments with the \f{ALLOCATABLE} attribute,
\begin{ttfamily}
  \begin{verbatim}
  ! Processing parameters
  INTEGER, PARAMETER :: N_SENSORS  =  1
  INTEGER, PARAMETER :: N_CHANNELS = 15
  CHARACTER(*), PARAMETER :: SID(N_SENSORS) = (/'amsua_n18'/)
  ! Declarations
  TYPE(CRTM_Atmosphere_type)  , ALLOCATABLE :: atm(:)
  TYPE(CRTM_Surface_type)     , ALLOCATABLE :: sfc(:)
  TYPE(CRTM_GeometryInfo_type), ALLOCATABLE :: gInfo(:)  
  TYPE(CRTM_ChannelInfo_type)               :: chInfo(N_SENSORS)
  TYPE(CRTM_RTSolution_type)  , ALLOCATABLE :: rts(:,:)\end{verbatim}
\end{ttfamily}

\subsubsection{Example 3: Fixed number of profiles but ``unknown'' sensor}
%.........................................................................
\refstepcounter{example}
\label{sec:declare_step_unksensor_ex}
Let's assume you'll be serially processing multiple sensors for a fixed number of profiles (REF TO MULTI SENSOR PROCESSING - SERIAL AND PARALLEL). What this means is that you don't necessarily know the number of channels since they could be different for different sensors. This means the RTSolution argument, \f{rts}, has an unknown dimension and must be declared with the \f{ALLOCATABLE} attribute,
\begin{ttfamily}
  \begin{verbatim}
  ! Processing parameters
  INTEGER, PARAMETER :: N_SENSORS  =  1
  INTEGER, PARAMETER :: N_PROFILES = 50
  ! Declarations
  CHARACTER(STRLEN)                       :: sId(N_SENSORS)
  TYPE(CRTM_Atmosphere_type)              :: atm(N_PROFILES)
  TYPE(CRTM_Surface_type)                 :: sfc(N_PROFILES)
  TYPE(CRTM_GeometryInfo_type)            :: gInfo(N_PROFILES)
  TYPE(CRTM_ChannelInfo_type)             :: chInfo(N_SENSORS)
  TYPE(CRTM_RTSolution_type), ALLOCATABLE :: rts(:,:)\end{verbatim}
\end{ttfamily}
Note also the use of the parameter \f{STRLEN} in the Sensor Id declaration. This character length definition is inherited from the \f{CRTM\_Module} and is used throughout the CRTM as the length of the Sensor Id string. Currently it's value is 20, but that could change in the future. Suffice it to say you should use the \f{STRLEN} parameter for Sensor Id character string declarations.

\subsubsection{Example 4: Variable number of profiles and sensors}
%.................................................................
\refstepcounter{example}
\label{sec:declare_step_allvar_ex}
This is a bit of a ``cover all your bases'' example, where we'll assume you'll be processing an unknown number of multiple sensors \textit{in parallel}\footnote{It doesn't make sense to process multiple sensors serially since each sensor will have most likely have different viewing geometries even if their fields of view (FOVs) correspond geographically.} for a variable number of profiles. This simply means everything is declared with the \f{ALLOCATABLE} attribute,
\begin{ttfamily}
  \begin{verbatim}
  ! Declarations
  CHARACTER(STRLEN)           , ALLOCATABLE :: sId(:)
  TYPE(CRTM_Atmosphere_type)  , ALLOCATABLE :: atm(:)
  TYPE(CRTM_Surface_type)     , ALLOCATABLE :: sfc(:)
  TYPE(CRTM_GeometryInfo_type), ALLOCATABLE :: gInfo(:)  
  TYPE(CRTM_ChannelInfo_type) , ALLOCATABLE :: chInfo(:)
  TYPE(CRTM_RTSolution_type)  , ALLOCATABLE :: rts(:,:)\end{verbatim}
\end{ttfamily}
Note also the use of the parameter \f{STRLEN} in the Sensor Id declaration. This character length definition is inherited from the \f{CRTM\_Module} and is used throughout the CRTM as the length of the Sensor Id string. Currently it's value is 20, but that could change in the future. Suffice it to say you should use the \f{STRLEN} parameter for Sensor Id character string declarations.

\subsection{Step 3: Initialise the CRTM}
%---------------------------------------
\stepcounter{step}
This step involves calling the \f{CRTM\_Init()} function in the \f{CRTM\_LifeCycle.f90} module to load all the various coefficient data used by CRTM components into memory for later use. We'll assume that all the required datafiles reside in the subdirectory \f{./coeff\_data} and follow on from the examples of Step \ref{sec:declare_step}.

\subsubsection{Example 1: Fixed number of sensors}
%....................................................
\refstepcounter{example}
Here you're using the ChannelInfo and Sensor Id arrays as declared in examples \ref{sec:declare_step_allfixed_ex} through \ref{sec:declare_step_unksensor_ex} of Step \ref{sec:declare_step},
\begin{ttfamily}
  \begin{verbatim}
  CHARACTER(*), PARAMETER :: PROGRAM_NAME='My Program Name'
  INTEGER :: errStatus
  ....
  errStatus = CRTM_Init( chInfo, Sensor_Id=SID, File_Path='./coeff_data' )
  IF ( errStatus /= SUCCESS ) THEN 
    CALL Display_Message( PROGRAM_NAME, &
                          'Error initializing CRTM', & 
                          errStatus )
    STOP
  END IF\end{verbatim}
\end{ttfamily}
Here we see for the first time how the CRTM functions let you know if they were successful. As you can see the function result is an error status that is checked against a parameterised error code, \f{SUCCESS}. Other available error code parameters are \f{FAILURE}, \f{WARNING}, and \f{INFORMATION}; although the latter is never used as a function result. Note that you don't have to call the error message handler subroutine \f{Display\_Message}, it just outputs messages in a standard way (see appendix \ref{sec:utility_message_handler}) and is used throughout the CRTM code.

\subsubsection{Example 2: Variable number of sensors}
%....................................................
\refstepcounter{example}
This example follows on from example \ref{sec:declare_step_allvar_ex} of Step \ref{sec:declare_step}. For this sort of usage you will need to allocate the ChannelInfo and Sensor Id arguments to the number of sensors you wish to process as well as fill it. For illustrative purposes only, let's assume for the latter you simply type in the number and list of sensors,
\begin{ttfamily}
  \begin{verbatim}
  CHARACTER(256) :: Message
  INTEGER :: n, n_Sensors
  ....
  ! Allocate the channelInfo and Sensor Id array
  READ( *,'(/2x,"Enter the number of sensors to process: ")', ADVANCE="NO" ) n_Sensors
  ALLOCATE( chInfo(n_Sensors), sId(n_Sensors), STAT=errStatus )
  IF ( errStatus /= 0 ) THEN
    WRITE( Message,'("Error allocating the chInfo and sId arrays. STAT=",i0)' ) errStatus
    CALL Display_Message( PROGRAM_NAME, &
                          TRIM(Message), & 
                          FAILURE )
    STOP
  END IF
  
  ! Get user sensor id input
  DO n = 1, n_Sensors
    READ( *,'(4x,"Enter sensor id #",i0,": ")', ADVANCE="NO" ) sId(n)
  END DO
  
  ! Initialise the CRTM for the dynamic sensor list
  errStatus = CRTM_Init( chInfo, Sensor_Id=sId, File_Path='./coeff_data' )
  IF ( errStatus /= SUCCESS ) THEN 
    CALL Display_Message( PROGRAM_NAME, &
                          'Error initializing CRTM', & 
                          errStatus )
    STOP
  END IF\end{verbatim}
\end{ttfamily}
This is, of course, a rather contrived example since it is guaranteed that typing in sensor identifiers by hand will get quite annoying very quickly.

One thing to note in the above example is the use of the error status variable \f{errStatus} for both standard errors (e.g. the allocation \f{STAT} result) and CRTM errors. In the former case, \f{errStatus} doesn't have any meaning for the \f{Display\_Message} subroutine\footnote{Indeed, the actual values of standard error codes can vary widely not only with the cause of the error, but also with compiler, operating system, and combinations thereof.}, hence the use of the actual fail parameter \f{FAILURE} in the call.


\subsection{Step 4: Allocate the CRTM structures}
%------------------------------------------------
\stepcounter{step}
If you've declared everything for a fixed number of sensors/channels and profiles (e.g. as shown in example \ref{sec:declare_step_allfixed_ex} of Step \ref{sec:declare_step}), then you can skip to the next step.

\subsubsection{Example 1: Variable number of profiles}
%.....................................................
\refstepcounter{example}
The following allocations apply to the declarations shown in example \ref{sec:declare_step_varprof_ex} of step \ref{sec:declare_step}, where the \f{N\_CHANNELS} parameter is declared,
\begin{ttfamily}
  \begin{verbatim}
  INTEGER :: n_Profiles
  ....
  ! Determine the number of profiles to process
  READ( *,'(/2x,"Enter the number of profiles to process: ")', ADVANCE="NO" ) n_Profiles
  
  ! Allocate the structure arrays
  ALLOCATE( atm(n_Profiles), &
            sfc(n_Profiles), &
            gInfo(n_Profiles), &
            rts(N_CHANNELS, n_Profiles), &
            STAT=errStatus )
  IF ( errStatus /= 0 ) THEN 
    WRITE( Message,'("Error allocating the structure arrays. STAT=",i0)' ) errStatus
    CALL Display_Message( PROGRAM_NAME, &
                          TRIM(Message), & 
                          FAILURE )
    STOP
  END IF\end{verbatim}
\end{ttfamily}

\subsubsection{Example 2: Fixed number of profiles but ``unknown'' sensor}
%.........................................................................
\refstepcounter{example}
Here the only unknown is the number of channels since the sensor is ``unknown'' at compile time, as shown in example \ref{sec:declare_step_unksensor_ex} of Step \ref{sec:declare_step}. Thus only the RTSolution argument needs allocating, but using the number of channels determined from the initialisation step,
\begin{ttfamily}
  \begin{verbatim}
  INTEGER :: n_Channels
  ....
  ! Allocate the structure arrays
  ALLOCATE( rts(chInfo(1)%n_Channels, n_Profiles), &
            STAT=errStatus )
  IF ( errStatus /= 0 ) THEN 
    WRITE( Message,'("Error allocating the structure arrays. STAT=",i0)' ) errStatus
    CALL Display_Message( PROGRAM_NAME, &
                          TRIM(Message), & 
                          FAILURE )
    STOP
  END IF\end{verbatim}
\end{ttfamily}
The ChannelInfo structure contains the number of sensor channels (see appendix \ref{sec:channelinfo_structure} for its full definition). The only thing to point out here is that even though we are only processing a single sensor, we still have to indicate the \f{chInfo} element for that sensor, \f{chInfo(1)}, when accessing the number of channel component.


\subsubsection{Example 3: Variable number of profiles and sensors}
%.................................................................
\refstepcounter{example}
Here everything is unknown. In particular the number of channels,
\begin{ttfamily}
  \begin{verbatim}
  INTEGER :: n_Channels
  ....
  ! Determine the total number of channels for all the sensors
  n_Channels = SUM(chInfo%n_Channels)
  
  ! Determine the number of profiles to process
  READ( *,'(/2x,"Enter the number of profiles to process: ")', ADVANCE="NO" ) n_Profiles
  
  ! Allocate the structure arrays
  ALLOCATE( atm(n_Profiles), &
            sfc(n_Profiles), &
            gInfo(n_Profiles), &
            rts(n_Channels, n_Profiles), &
            STAT=errStatus )
  IF ( errStatus /= 0 ) THEN 
    WRITE( Message,'("Error allocating the structure arrays. STAT=",i0)' ) errStatus
    CALL Display_Message( PROGRAM_NAME, &
                          TRIM(Message), & 
                          FAILURE )
    STOP
  END IF\end{verbatim}
\end{ttfamily}
Note that now we are 
\subsection{Step 5: Fill the CRTM input structures with data}
%------------------------------------------------------------

\subsection{Step 6: Call the required cRTM function}
%---------------------------------------------------

\subsection{Step 7: Destroy the CRTM}
%------------------------------------


\section{Interface Descriptions}
%===============================

\subsection{CRTM Initialisation}
%-------------------------------

\begin{figure}[htp]
  \centering
  \doublebox{
  \begin{minipage}[b]{6.5in}
    \begin{ttfamily}
      \begin{verbatim}
  FUNCTION CRTM_Init( ChannelInfo      , &
                      Sensor_ID        , &
                      CloudCoeff_File  , &
                      AerosolCoeff_File, &
                      EmisCoeff_File   , &
                      File_Path        , &
                      Quiet            , &
                      Process_ID       , &
                      Output_Process_ID, &
                      RCS_Id           , &
                      Message_Log      ) &
                    RESULT( Error_Status )

    ! Arguments
    TYPE(CRTM_ChannelInfo_type), INTENT(IN OUT) :: ChannelInfo(:)
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: Sensor_ID(:)
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: CloudCoeff_File
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: AerosolCoeff_File
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: EmisCoeff_File
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: File_Path
    INTEGER     ,      OPTIONAL, INTENT(IN)     :: Quiet
    INTEGER     ,      OPTIONAL, INTENT(IN)     :: Process_ID
    INTEGER     ,      OPTIONAL, INTENT(IN)     :: Output_Process_ID
    CHARACTER(*),      OPTIONAL, INTENT(OUT)    :: RCS_Id
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: Message_Log
    ! Function result
    INTEGER :: Error_Status
      \end{verbatim}
    \end{ttfamily}
    \centering
    \begin{tabular}{p{3.25cm} p{6.5cm} p{1.75cm} p{2.5cm}}
      \hline
      \tblhd{Argument}             & \tblhd{Description}                             & \tblhd{Rank} & \tblhd{Intent} \\
      \hline\hline
      \f{ChannelInfo}              & Sensor and channel info structure               & $N$          & Output \\
      \optarg{Sensor\_Id}          & \textit{Sensor identification string}           & $N$          & \textit{Input}  \\
      \optarg{CloudCoeff\_File}    & \textit{Cloud optical property LUT filename}    & Scalar       & \textit{Input}  \\
      \optarg{AerosolCoeff\_File}  & \textit{Aerosol optical property LUT filename}  & Scalar       & \textit{Input}  \\
      \optarg{EmisCoeff\_File}     & \textit{IR sea surface emissivity LUT filename} & Scalar       & \textit{Input}  \\
      \optarg{File\_Path}          & \textit{Path to *Coeff files}                   & Scalar       & \textit{Input}  \\
      \optarg{Quiet}               & \textit{Keyword to control info message output} & Scalar       & \textit{Input}  \\
      \optarg{Process\_Id}         & \textit{MPI process Id}                         & Scalar       & \textit{Input}  \\
      \optarg{Output\_Process\_Id} & \textit{MPI process Id for message output}      & Scalar       & \textit{Input}  \\
      \optarg{RCS\_Id}             & \textit{Version control ID for the module}      & Scalar       & \textit{Output} \\
      \optarg{Message\_Log}        & \textit{Log message filename}                   & Scalar       & \textit{Input} 
    \end{tabular}
  \end{minipage}
  }
  \caption{CRTM Initialisation interface and argument description.}
  \label{fig:init_interface}
\end{figure}

\subsection{Forward Model}
%-------------------------

\begin{figure}[htp]
  \centering
  \doublebox{
  \begin{minipage}[b]{6.5in}
    \begin{ttfamily}
      \begin{verbatim}
  FUNCTION CRTM_Forward( Atmosphere  , &
                         Surface     , &
                         GeometryInfo, &
                         ChannelInfo , &
                         RTSolution  , &
                         Options     , &    
                         RCS_Id      , &
                         Message_Log ) &
                       RESULT( Error_Status )
    ! Arguments
    TYPE(CRTM_Atmosphere_type),        INTENT(IN)     :: Atmosphere(:)
    TYPE(CRTM_Surface_type),           INTENT(IN)     :: Surface(:)
    TYPE(CRTM_GeometryInfo_type),      INTENT(IN OUT) :: GeometryInfo(:)
    TYPE(CRTM_ChannelInfo_type),       INTENT(IN)     :: ChannelInfo(:)
    TYPE(CRTM_RTSolution_type),        INTENT(IN OUT) :: RTSolution(:,:)
    TYPE(CRTM_Options_type), OPTIONAL, INTENT(IN)     :: Options(:)
    CHARACTER(*),            OPTIONAL, INTENT(OUT)    :: RCS_Id
    CHARACTER(*),            OPTIONAL, INTENT(IN)     :: Message_Log
    ! Function result
    INTEGER :: Error_Status
      \end{verbatim}
    \end{ttfamily}
    \centering
    \begin{tabular}{p{3.25cm} p{6.5cm} p{1.75cm} p{2.5cm}}
      \hline
      \tblhd{Argument}       & \tblhd{Description}                           & \tblhd{Rank} & \tblhd{Intent} \\
      \hline\hline
      \f{Atmosphere}         & Atmospheric state                             & $M$          & Input  \\
      \f{Surface}            & Surface state                                 & $M$          & Input  \\
      \f{GeometryInfo}       & Geometry information (e.g. angles)            & $M$          & Input  \\
      \f{ChannelInfo}        & Sensor channel information                    & $N$          & Input  \\
      \f{RTSolution}         & Radiative transfer solution                   & $L \times M$ & Output \\
      \optarg{Options}       & \textit{Structure containing optional inputs} & $M$          & \textit{Input}  \\
      \optarg{RCS\_Id}       & \textit{Version control ID for the module}    & Scalar       & \textit{Output} \\
      \optarg{Message\_Log}  & \textit{Log message filename}                 & Scalar       & \textit{Input} 
    \end{tabular}
  \end{minipage}
  }
  \caption{CRTM Forward model interface and argument description.}
  \label{fig:fwd_interface}
\end{figure}


\subsection{K-Matrix Model}
%--------------------------

\begin{figure}[htp]
  \centering
  \doublebox{
  \begin{minipage}[b]{6.5in}
    \begin{ttfamily}
      \begin{verbatim}
  FUNCTION CRTM_K_Matrix( Atmosphere  , &
                          Surface     , &
                          RTSolution_K, &
                          GeometryInfo, &
                          ChannelInfo , &
                          Atmosphere_K, &
                          Surface_K   , &
                          RTSolution  , &
                          Options     , &
                          RCS_Id      , &
                          Message_Log ) &
                        RESULT( Error_Status )
    ! Arguments
    TYPE(CRTM_Atmosphere_type)       , INTENT(IN)     :: Atmosphere(:)
    TYPE(CRTM_Surface_type)          , INTENT(IN)     :: Surface(:)
    TYPE(CRTM_RTSolution_type)       , INTENT(IN OUT) :: RTSolution_K(:,:)
    TYPE(CRTM_GeometryInfo_type)     , INTENT(IN OUT) :: GeometryInfo(:)
    TYPE(CRTM_ChannelInfo_type)      , INTENT(IN)     :: ChannelInfo(:)
    TYPE(CRTM_Atmosphere_type)       , INTENT(IN OUT) :: Atmosphere_K(:,:)
    TYPE(CRTM_Surface_type)          , INTENT(IN OUT) :: Surface_K(:,:)
    TYPE(CRTM_RTSolution_type)       , INTENT(IN OUT) :: RTSolution(:,:)
    TYPE(CRTM_Options_type), OPTIONAL, INTENT(IN)     :: Options(:)
    CHARACTER(*),            OPTIONAL, INTENT(OUT)    :: RCS_Id
    CHARACTER(*),            OPTIONAL, INTENT(IN)     :: Message_Log
    ! Function result
    INTEGER :: Error_Status
      \end{verbatim}
    \end{ttfamily}
    \centering
    \begin{tabular}{p{3.25cm} p{6.5cm} p{1.75cm} p{2.5cm}}
      \hline
      \tblhd{Argument}      & \tblhd{Description}                           & \tblhd{Rank} & \tblhd{Intent} \\
      \hline\hline
      \f{Atmosphere}        & Atmospheric state                             & $M$          & FWD Input  \\
      \f{Surface}           & Surface state                                 & $M$          & FWD Input  \\
      \f{RTSolution\_K}     & Adjoint radiative transfer solution           & $L \times M$ & K   Input  \\
      \f{GeometryInfo}      & Geometry information (e.g. angles)            & $M$          & Input      \\
      \f{ChannelInfo}       & Sensor channel information                    & $N$          & Input      \\
      \f{Atmosphere\_K}     & Atmospheric state Jacobians                   & $L \times M$ & K   Output \\
      \f{Surface\_K}        & Surface state Jacobians                       & $L \times M$ & K   Output \\
      \f{RTSolution}        & Radiative transfer solution                   & $L \times M$ & FWD Output \\
      \optarg{Options}      & \textit{Structure containing optional inputs} & $M$          & \textit{Input}  \\
      \optarg{RCS\_Id}      & \textit{Version control ID for the module}    & Scalar       & \textit{Output} \\
      \optarg{Message\_Log} & \textit{Log message filename}                 & Scalar       & \textit{Input} 
    \end{tabular}
  \end{minipage}
  }
  \caption{CRTM K-Matrix model interface and argument description.}
  \label{fig:k_interface}
\end{figure}


\subsection{CRTM Destruction}
%----------------------------

\begin{figure}[htp]
  \centering
  \doublebox{
  \begin{minipage}[b]{16.5cm}
    \begin{ttfamily}
      \begin{verbatim}
  FUNCTION CRTM_Destroy( ChannelInfo , &  ! Output
                         Process_ID  , &  ! Optional input
                         RCS_Id      , &  ! Revision control
                         Message_Log ) &  ! Error messaging
                       RESULT ( Error_Status )
    ! Arguments
    TYPE(CRTM_ChannelInfo_type), INTENT(IN OUT) :: ChannelInfo(:)
    INTEGER     ,      OPTIONAL, INTENT(IN)     :: Process_ID
    CHARACTER(*),      OPTIONAL, INTENT(OUT)    :: RCS_Id
    CHARACTER(*),      OPTIONAL, INTENT(IN)     :: Message_Log
    ! Function result
    INTEGER :: Error_Status
      \end{verbatim}
    \end{ttfamily}
    \centering
    \begin{tabular}{p{3.25cm} p{6.5cm} p{1.75cm} p{2.5cm}}
      \hline
      \tblhd{Argument}      & \tblhd{Description}                           & \tblhd{Rank} & \tblhd{Intent} \\
      \hline\hline
      \f{ChannelInfo}       & Sensor and channel info structure             & $N$          & In/Output       \\
      \optarg{Process\_Id}  & \textit{MPI process Id}                       & Scalar       & \textit{Input}  \\
      \optarg{RCS\_Id}      & \textit{Version control ID for the module}    & Scalar       & \textit{Output} \\
      \optarg{Message\_Log} & \textit{Log message filename}                 & Scalar       & \textit{Input} 
    \end{tabular}
  \end{minipage}
  }
  \caption{CRTM Destruction interface and argument description.}
  \label{fig:destroy_interface}
\end{figure}


\section{Filling input data structures}
%======================================

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/sensor_scan_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} sensor scan angle component.}
  \label{fig:gInfo_sensor_scan_angle}
\end{figure}

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/sensor_zenith_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} sensor zenith angle component.}
  \label{fig:gInfo_sensor_zenith_angle}
\end{figure}

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/sensor_azimuth_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} sensor azimuth angle component.}
  \label{fig:gInfo_sensor_azimuth_angle}
\end{figure}

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/source_zenith_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} source zenith angle component.}
  \label{fig:gInfo_source_zenith_angle}
\end{figure}

\begin{figure}[htp]
  \centering
  \input{graphics/gInfo/source_azimuth_angle.pstex_t}
  \caption{Definition of \GeometryInfo{} source azimuth angle component.}
  \label{fig:gInfo_source_azimuth_angle}
\end{figure}
